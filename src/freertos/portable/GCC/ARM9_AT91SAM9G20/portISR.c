/* The PIT interrupt handler - the RTOS tick. */
#include <board.h>
#include <pit/pit.h>
#include <irq/irq.h>
#include "FreeRTOS.h"
#include "task.h"

/* Constants required to handle critical sections. */
#define portNO_CRITICAL_NESTING		( ( uint32_t ) 0 )
volatile uint32_t ulCriticalNesting = 9999UL;

void vPortStartFirstTask (void);

void vPortStartFirstTask (void) {
  portRESTORE_CONTEXT();
}

/* ISR to handle manual context switches (from a call to taskYIELD()). */
void vPortYieldProcessor( void ) __attribute__((interrupt("SWI"), naked));


void vPortYieldProcessor (void){
  __asm volatile ("ADD LR, LR,#4");
  portSAVE_CONTEXT();
  vTaskSwitchContext();
  portRESTORE_CONTEXT();
}
		  
void vPortTickISR( void );

void vPortTickISR( void )
{
  portSAVE_CONTEXT();
  volatile uint32_t ulDummy;
  volatile uint32_t status;
  // Read the PIT status register
  if( xTaskIncrementTick() != pdFALSE )
    {
      vTaskSwitchContext();
    }
  status = PIT_GetStatus() & AT91C_PITC_PITS;
  if (status != 0) {
    // 1 = The Periodic Interval timer has reached PIV since the last read of PIT_PIVR.
    // Read the PIVR to acknowledge interrupt and get number of ticks
    //Returns the number of occurrences of periodic intervals since the last read of PIT_PIVR.
    ulDummy  += (PIT_GetPIVR() >> 20);
  }
  portRESTORE_CONTEXT();
  /* Increment the tick count - which may wake some tasks but as the
     preemptive scheduler is not being used any woken task is not given
     processor time no matter what its priority. */
}
/*-----------------------------------------------------------*/

/*
 * The interrupt management utilities can only be called from ARM mode.  When
 * THUMB_INTERWORK is defined the utilities are defined as functions here to
 * ensure a switch to ARM mode.  When THUMB_INTERWORK is not defined then
 * the utilities are defined as macros in portmacro.h - as per other ports.
 */

#ifdef THUMB_INTERWORK

void vPortDisableInterruptsFromThumb( void ) __attribute__ ((naked));
void vPortEnableInterruptsFromThumb( void ) __attribute__ ((naked));

void vPortDisableInterruptsFromThumb( void )
{
	__asm volatile (
		"STMDB	SP!, {R0}		\n\t"	/* Push R0.									*/
		"MRS	R0, CPSR		\n\t"	/* Get CPSR. */
		"ORR    R0, R0, #0x80\n"
		"MSR    CPSR, R0\n"	
		"ORR    R0, R0, #0x40\n"
		"MSR	CPSR, R0		\n\t"	
		"LDMIA	SP!, {R0}		\n\t"	/* Pop R0.									*/
		"BX		R14" );					/* Return back to thumb.					*/
}

void vPortEnableInterruptsFromThumb( void )
{
	__asm volatile (
		"STMDB	SP!, {R0}		\n\t"	/* Push R0.									*/
		"MRS	R0, CPSR		\n\t"	/* Get CPSR.								*/
		"BIC	R0, R0, #0xC0	\n\t"	/* Enable IRQ, FIQ.							*/
		"MSR	CPSR, R0		\n\t"	/* Write back modified value.				*/
		"LDMIA	SP!, {R0}		\n\t"	/* Pop R0.									*/
		"BX		R14" );					/* Return back to thumb.					*/
}

#endif


/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
void vPortEnterCritical( void )
{
	/* Disable interrupts as per portDISABLE_INTERRUPTS(); 							*/
  	__asm volatile (
		"STMDB	SP!, {R0}		\n\t"	/* Push R0.									*/
		"MRS	R0, CPSR		\n\t"	/* Get CPSR. */
		"ORR    R0, R0, #0x80\n"
		"MSR    CPSR, R0\n"	
		"ORR    R0, R0, #0x40\n"
		"MSR	CPSR, R0		\n\t" 
		"LDMIA	SP!, {R0}		\n\t"	/* Pop R0.									*/
		"BX		R14" );


	/* Now interrupts are disabled ulCriticalNesting can be accessed
	directly.  Increment ulCriticalNesting to keep a count of how many times
	portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
}

void vPortExitCritical( void )
{
	if( ulCriticalNesting > portNO_CRITICAL_NESTING )
	{
		/* Decrement the nesting count as we are leaving a critical section. */
		ulCriticalNesting--;

		/* If the nesting level has reached zero then interrupts should be
		re-enabled. */
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
		{
			/* Enable interrupts as per portEXIT_CRITICAL().					*/
			__asm volatile (
				"STMDB	SP!, {R0}		\n\t"	/* Push R0.						*/
				"MRS	R0, CPSR		\n\t"	/* Get CPSR.					*/
				"BIC	R0, R0, #0xC0	\n\t"	/* Enable IRQ, FIQ.				*/
				"MSR	CPSR, R0		\n\t"	/* Write back modified value.	*/
				"LDMIA	SP!, {R0}" );			/* Pop R0.						*/
		}
	}
}
